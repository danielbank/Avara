/*/    Copyright ©1995, Juri Munkki    All rights reserved.    File: CZombieActor.c copy    Created: Tuesday, October 31, 1995, 14:58    Modified: Wednesday, November 15, 1995, 7:14/*/#include "CZombieActor.h"#include "CSmartPart.h"#define	zombieFireHeight	FIX3(1200)#define	zombieScanDistance	FIX1(64)#define	zombieMaxLookSide	FIX1(4)#define	zombieFarDistance	FIX1(20)#define	zombieCloseDistance	FIX1(9)#define	zombieRealCloseDistance	FIX1(4)#define	zombieAccel			FIX3(50)#define	zombieFriction		FIX3(970)CAbstractActor *	CZombieActor::EndScript(){	short	i;	if(inherited::EndScript())	{	long	repColor;			isTarget = true;		isActive = true;		speed = 0;		job.will = 0;		job.decrWill = 0;		job.accel = 0;		job.turnRate = 0;		job.owner = zaNothing;				partCount = 2;		LoadPart(0, 810);		LoadPart(1, 811);				repColor = GetPixelColor();		partList[0]->ReplaceColor(kMarkerColor, repColor);		partList[1]->ReplaceColor(kMarkerColor, repColor);				bigRadius = partList[0]->bigRadius;		if(partList[1]->bigRadius > bigRadius)			bigRadius = partList[1]->bigRadius;				cornerAngle = FOneToDeg(FOneArcTan2(-partList[0]->header.minBounds.z,											-partList[0]->header.minBounds.x));		for(i=0;i<zaScanCount;i++)		{	lastScans[i] = zombieScanDistance*2;		}		PlaceParts();		return this;	}	else		return NULL;}void	CZombieActor::PlaceParts(){	UnlinkLocation();	partList[0]->Reset();	partList[0]->RotateY(heading);	partList[0]->Translate(location[0], location[1], location[2]);	partList[0]->MoveDone();	partList[1]->CopyTransform(&partList[0]->itsTransform);	partList[1]->MoveDone();	LinkPartSpheres();}Fixed	CZombieActor::ScanDirection(	Fixed			direction,	RayHitRecord	*target){	target->origin[0] = location[0];	target->origin[1] = location[1] + zombieFireHeight;	target->origin[2] = location[2];	target->direction[0] = FDegSin(direction);	target->direction[1] = 0;	target->direction[2] = FDegCos(direction);	target->distance = zombieScanDistance;	target->closestHit = NULL;	RayTest(target);		return target->distance;}void	CZombieActor::MoveForward(){	location[0] += FMul(speed, FDegSin(heading));	location[2] += FMul(speed, FDegCos(heading));	PlaceParts();}void	CZombieActor::SavePosition(){	oldLoc[0] = location[0];	oldLoc[2] = location[2];	oldHeading = heading;}void	CZombieActor::UndoMove(){	location[0] = oldLoc[0];	location[2] = oldLoc[2];	heading = oldHeading;}void	CZombieActor::Vote(	ZombieJob	*newWill){	if(newWill->will > job.will)	{	job.will = newWill->will + (newWill->decrWill << 5);		job.decrWill = newWill->decrWill;		job.accel = newWill->accel;		job.turnRate = newWill->turnRate;		job.owner = newWill->owner;	}}void	CZombieActor::VoteForward(){	RayHitRecord	scan;	ZombieJob		newJob;	Fixed			theRandom = FRandom();	ScanDirection(heading, &scan);		lastScans[zaForward] = scan.distance;	newJob.accel = zombieAccel;	newJob.turnRate = 0;	newJob.owner = zaForward;		if(scan.distance < zombieCloseDistance)	{	newJob.will = FMul(theRandom, theRandom) + FIX3(300);				if(scan.distance < zombieCloseDistance/2)		{	newJob.turnRate = -cornerAngle >> 5;			newJob.will += FIX3(100);		}		if(didBump)		{	newJob.will += FIX3(250);			newJob.turnRate = cornerAngle >> 4;		}		newJob.decrWill = FIX3(100);		newJob.accel = -zombieAccel;	}	else	if(scan.distance < zombieFarDistance)	{	newJob.will = FMul(theRandom, theRandom)					 + FMulDiv(zombieCloseDistance, FIX1(1), scan.distance);		newJob.decrWill = FIX3(100);		newJob.accel >>= 1;	}	else if(scan.distance < zombieScanDistance)	{	newJob.will = theRandom + FMulDiv(zombieScanDistance, FIX1(1), scan.distance);		newJob.decrWill = FIX3(100);	}	else	{	newJob.will = 0;		newJob.decrWill = 0;	}	if(didBump) newJob.will >>= 1;	Vote(&newJob);}void	CZombieActor::VoteTurn(	Fixed	probeAngle,	short	actionOwner){	RayHitRecord	scan;	ZombieJob		newJob;	Fixed			theRandom = FRandom();		ScanDirection(heading+probeAngle, &scan);	lastScans[actionOwner] = scan.distance;	newJob.accel = zombieAccel;	newJob.turnRate = probeAngle >> 4;	newJob.owner = actionOwner;		if(scan.distance < zombieCloseDistance)	{	newJob.will = FMul(theRandom, theRandom) + FIX3(350);		if(didBump)		{	newJob.will += FIX3(150);			if(didBump > 0)				newJob.accel = -zombieAccel;		}		newJob.turnRate = - newJob.turnRate;		if(scan.distance < zombieRealCloseDistance)			newJob.turnRate += newJob.turnRate;		newJob.decrWill = FIX3(100);	}	else	if(scan.distance < zombieFarDistance)	{	newJob.will = (theRandom>>1) + FMulDiv(zombieCloseDistance, FIX1(3), scan.distance);		newJob.decrWill = FIX3(100);		newJob.turnRate = -(newJob.turnRate >> 1);		newJob.accel >>= 1;	}	else if(scan.distance < zombieScanDistance)	{	newJob.will = FMul(theRandom, theRandom) * 2 + 						FMulDiv(zombieFarDistance, FIX3(1500), scan.distance);		newJob.decrWill = FIX3(200);		newJob.turnRate = (newJob.turnRate >> 2);	}	else	{	newJob.will = 0;		newJob.decrWill = 0;	}	Vote(&newJob);}void	CZombieActor::VoteTurnAround(){	short		i;	ZombieJob	newJob;		for(i=0;i<zaScanCount;i++)	{	if(lastScans[i] < zombieFarDistance)			return;	}		newJob.owner = zaTurnAround;	newJob.turnRate = cornerAngle >> 4;	if(job.turnRate < 0)		newJob.turnRate = -newJob.turnRate;	newJob.accel = 0;	newJob.will = FIX1(3);	newJob.decrWill = FIX3(200);	Vote(&newJob);}void	CZombieActor::FrameAction(){	inherited::FrameAction();	SavePosition();		if(job.owner != zaForward)		VoteForward();	if(job.owner != zaCounterClock)		VoteTurn(cornerAngle, zaCounterClock);	if(job.owner != zaClockwise)		VoteTurn(-cornerAngle, zaClockwise);	if(job.owner != zaTurnAround)		VoteTurnAround();	speed += job.accel;	heading += job.turnRate;	job.will -= job.decrWill;	if(job.will < 0)	{	job.will = 0;	}	speed = FMul(speed, zombieFriction);	MoveForward();	BuildPartProximityList(location, bigRadius);	if(DoCollisionTest())	{	didBump = speed;		UndoMove();		PlaceParts();		speed = 0;		job.turnRate = 0;		job.accel = -job.accel;		job.will -= job.decrWill;	}	else	{	didBump = 0;	}	}