/*/    Copyright ©1992-1996, Juri Munkki    All rights reserved.    File: AddPolySegment.body    Created: Thursday, November 26, 1992, 1:02    Modified: Wednesday, February 7, 1996, 22:15/*//***	This is just the body of a function, so you can't compile it alone.**	the idea is that you include this file into the 68000 version of the**	function, set the mot68020 flag and then include it again in the**	68020 version. This way the function is easier to maintain, since a**	large part of the code is shared between the 68000 and 68020 versions.*/{asm	{		movem.l	A2/D2-D4,-(sp)				move.l	thePolyWorld,A0		move.w	PolyWorld.xOffset(A0),D0		move.w	D0,D1		add.w	p1.h,D0		add.w	p2.h,D1		cmp.w	OFFSET(PolyWorld,bounds.right)(A0),D0		blt.s	@noXClip						; Line is on left side of clip bound		cmp.w	OFFSET(PolyWorld,bounds.right)(A0),D1		bge		@noEdge							; Line is totally on right side of clip bound@noXClip		move.w	p1.v,D2		move.w	p2.v,D3		cmp.w	D2,D3		beq		@noEdge		bge.s	@noSwap		exg		D0,D1		exg		D2,D3@noSwap		tst.w	D3		ble		@noEdge						; Edge is above viewport		cmp.w	OFFSET(PolyWorld,height)(A0),D2		bge		@noEdge						; Edge is below viewport		move.l	OFFSET(PolyWorld,newEdge)(A0),A1		cmp.l	OFFSET(PolyWorld,endEdge)(A0),A1		bcc		@noEdge		#ifdef mot68020		swap	D0		swap	D1		clr.w	D0		clr.w	D1		move.w	D3,D4		sub.l	D0,D1							; D1 = delta x		sub.w	D2,D4							; D4 = delta y		ext.l	D4		divs.l	D4,D1							; D1 = slope of this line		move.l	D1,PolyEdge.dx(A1)				; Store slope #else		move.w	D3,D4		sub.w	D2,D4		sub.w	D0,D1		swap	D0		clr.w	D0		ext.l	D1		bmi.s	@negativeSlope		divu.w	D4,D1		move.w	D1,PolyEdge.dx(A1)		clr.w	D1		divu.w	D4,D1		move.w	D1,(2+(short)(PolyEdge.dx))(A1)		bra.s	@skipNegSlope@negativeSlope		neg.l	D1		divu.w	D4,D1		move.w	D1,PolyEdge.dx(A1)		clr.w	D1		divu.w	D4,D1		move.w	D1,(2+(short)(PolyEdge.dx))(A1)		neg.l	PolyEdge.dx(A1)@skipNegSlope		move.l	PolyEdge.dx(A1),D1#endif				ext.l	D2		bpl.s	@noClip#ifdef mot68020		muls.l	D1,D2		sub.l	D2,D0#else		neg.w	D2		move.l	D1,D4		bmi.s	@negativeClipDistance		beq.s	@skipNegClip		mulu.w	D2,D4		add.l	D4,D0		move.l	D1,D4		swap	D4		mulu.w	D2,D4		swap	D4		add.l	D4,D0		bra.s	@skipNegClip@negativeClipDistance		neg.w	D4		mulu.w	D2,D4		sub.l	D4,D0		move.l	D1,D4		neg.l	D4		swap	D4		mulu.w	D2,D4		swap	D4		sub.l	D4,D0@skipNegClip#endif		clr.w	D2@noClip		asr.l	#1,D1		add.l	D1,D0							; Move x to next half-pixel		sub.l	PolyEdge.dx(A1),D0		move.l	D0,PolyEdge.x(A1)		move.l	OFFSET(PolyWorld,onLists)(A0),A2		move.l	(A2,D2.w*4),D0		move.l	A1,(A2,D2.w*4)		move.l	D0,PolyEdge.nextOn(A1)		cmp.w	OFFSET(PolyWorld,height)(A0),D3		bge.s	@noOffList		move.l	OFFSET(PolyWorld,offLists)(A0),A2		move.l	-4(A2,D3.w*4),D0		move.l	A1,-4(A2,D3.w*4)		move.l	D0,PolyEdge.nextOff(A1)@noOffList		move.w	PolyWorld.currentColor(A0),PolyEdge.color(A1)		move.w	OFFSET(PolyWorld,polyCount)(A0),PolyEdge.polyID(A1)		add.l	#sizeof(PolyEdge),OFFSET(PolyWorld,newEdge)(A0)@noEdge		movem.l	(sp)+,A2/D2-D4	}}