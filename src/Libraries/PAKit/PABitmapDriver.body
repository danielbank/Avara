/*/    Copyright ©1992, Juri Munkki    All rights reserved.    File: PABitmapDriver.body    Created: Friday, November 27, 1992, 0:32    Modified: Thursday, December 10, 1992, 11:15/*//***	This is just the body of a function, so you can't compile it alone.**	the idea is that you include this file into the 68000 version of the**	function, set the mot68020 flag and then include it again in the**	68020 version. This way the function is easier to maintain, since a**	large part of the code is shared between the 68000 and 68020 versions.*/{asm	{		movem.l	D3-D7/A2-A5,-(sp)		move.l	diffp,A0		move.l	baseAddr,A2		move.w	rightEdge,D6		lea		MASKOFFSET+(char *)MASKTABLE,A3		move.l	colorTable,A1		move.l	(A1),A1		moveq.l	#0,D7			;	This is the pattern offset		bra.s	@mainLoop@earlyLoop		move.l	D5,(A5)@mainLoop		move.w	(A0)+,D1		;	This is x1		cmp.w	D6,D1		bge		@nextRow		moveq.l	#BITSINLONG-1,D0		and.w	D1,D0			;	Copy x1		sub.w	D0,D1			;	Leave everything else#ifdef mot68020		move.l	MASKOFFSET(A3,D0.w*4),D0#else		lsl.w	#2,D0			;	Multiply by 4		move.l	64(A3,D0),D0	;	Mask is now in D0#endif		lsr.w	#RIGHTSHIFT,D1	;	Byte offset is now in D1		lea		(A2,D1.w),A5	;	This is the address of the pixels		move.l	(A5),D5			;	D5 contains the pixels@x1ok		move.w	(A0)+,D2		;	This is the color index		bmi.s	@earlyLoop		;	Negative colors are not drawn		lsl.w	#5,D2			;	Patterns are 32 bytes each.		add.w	D7,D2			;	Add pattern row offset		move.l	(A1,D2.w),D2	;	Load pattern				move.w	(A0),D3			;	This is x2		moveq.l	#BITSINLONG-1,D4		and.w	D3,D4			;	Copy to D4		sub.w	D4,D3			;	Leave everything else#ifdef mot68020		move.l	-MASKOFFSET(A3,D4.w*4),D4#else		lsl.w	#2,D4			;	Multiply by 4		move.l	-64(A3,D4),D4	;	Read mask into D4#endif		lsr.w	#RIGHTSHIFT,D3	;	Offset is now in D3		sub.w	D3,D1			;	Is the memory address the same?		bne.s	@notInSameWord	;	No, do something more difficult		eor.l	D0,D4		move.w	D3,D1		and.l	D4,D5			;	mask with 1100..011		not.l	D4		and.l	D4,D2			;	mask with 0011..100		or.l	D2,D5			;	or with pattern		eor.l	D4,D0						cmp.w	(A0)+,D6		bne.s	@x1ok		bra		@nextRowAndWrite		@notInSameWord		or.l	D0,D5		eor.l	D0,D5		and.l	D2,D0			;	Create clipped off pattern		or.l	D0,D5			;	Combine pattern and video data		move.l	D5,(A5)+		moveq.l	#-40,D0		asr.w	#1,D1		cmp.w	D0,D1		bge.s	@goJump@bigCopy		dc.w	0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2		dc.w	0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2		dc.w	0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2		dc.w	0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2		sub.w	D0,D1		cmp.w	D0,D1		blt.s	@bigCopy		@goJump		jmp		@finishUp+2(PC,D1.w)		move.l	D2,(A5)+		; Opcode is 2AC2		dc.w	0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2		dc.w	0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2		dc.w	0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2		dc.w	0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2, 0x2AC2		@finishUp		move.l	D4,D0			;	Keep a copy of the mask		not.l	D0		and.l	D4,D2		move.l	(A5),D5		and.l	D0,D5		or.l	D2,D5		move.w	D3,D1			;	D1 is now offset of x2		cmp.w	(A0)+,D6		bne		@x1ok@nextRowAndWrite		move.l	D5,(A5)@nextRow		addq.l	#4,D7			;	Add to pattern offset		and.b	#0x1F,D7		;	Keep offset within 32 bytes		add.w	rowBytes,A2		subq.w	#1,rowCount		bne		@mainLoop@stop		movem.l	(sp)+,D3-D7/A2-A5	}}#undef	MASKTABLE#undef	MASKOFFSET#undef	PATTERNTABLE#undef	BITSINLONG#undef	RIGHTSHIFT